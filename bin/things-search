#!/usr/bin/env python3

#
# Search things returning a stream of rows with 3 ":" separated parts ;
#
# 1) Sortable key, e.g. timestamp
# 2) Filename, i.e. where the match exists
# 3) Display string, i.e. what should be displayed in fzf
#

import argparse
import configparser
import subprocess
import sys
from pathlib import Path
from subprocess import PIPE


config = configparser.ConfigParser()
config.read(str(Path.home()) + "/.config/dotme/shim.ini")
THINGS_DIR = config["DEFAULT"]["THINGS_DIR"]


def run():
    parser = argparse.ArgumentParser(description="things")
    parser.add_argument("thing", nargs="*", help="thing")
    parser.add_argument("-n", "--name", help="search name", default="default")
    parser.add_argument("--nofilter", action="store_true")
    parser.add_argument("--dry", action="store_true")
    args = parser.parse_args()

    search(args)


# Make a part safe for executing as shell command. This allows the output from a
# dry run report to be cut and pasted into a shell window
def commandPartShellSafe(part):
    if part.startswith("s/") or part.startswith("*"):
        return f"'{part}'"
    return part


def shellSafe(parts):
    return map(commandPartShellSafe, parts)


class Search:
    def __init__(self):
        self.withModifiedKey = False
        self.sort = False
        self.maxPerFile = 0
        self.filter = "s/^/:/"
        self.matchPrefix = ""
        self.postFilter = None

    # Command to search for things
    def createCommand(self):
        return ["fd"]

    # Filter command to get output into desired 3 part format
    def createFilterCommand(self):
        if self.withModifiedKey:
            return ["things-with-modified.awk"]
        elif self.filter is not None:
            return ["sed", self.filter]
        else:
            return []

    def createPostFilterCommand(self):
        if self.postFilter is not None:
            return ["sed", self.postFilter]
        else:
            return []

    def createSortCommand(self):
        if self.sort:
            return ["sort", "-r"]
        else:
            return []

    def run(self, args):
        command = self.createCommand()
        filterCommand = self.createFilterCommand()
        postFilterCommand = self.createPostFilterCommand()
        sortCommand = self.createSortCommand()

        if args.dry:
            command = " ".join(shellSafe(command))
            if len(filterCommand) > 0:
                command += " | " + " ".join(shellSafe(filterCommand))
            if len(postFilterCommand) > 0:
                command += " | " + " ".join(shellSafe(postFilterCommand))
            if len(sortCommand) > 0:
                command += " | " + " ".join(shellSafe(sortCommand))
            print(command)
            return
        pipe = subprocess.Popen(command, stdout=PIPE, cwd=THINGS_DIR, text=True)
        pipeIn = pipe
        if len(filterCommand) > 0:
            pipe = subprocess.Popen(
                filterCommand, stdin=pipe.stdout, stdout=PIPE, text=True, cwd=THINGS_DIR
            )
        if len(postFilterCommand) > 0:
            pipe = subprocess.Popen(
                postFilterCommand,
                stdin=pipe.stdout,
                stdout=PIPE,
                text=True,
                cwd=THINGS_DIR,
            )
        if len(sortCommand) > 0:
            pipe = subprocess.Popen(
                sortCommand, stdin=pipe.stdout, stdout=PIPE, text=True, cwd=THINGS_DIR
            )
        for line in iter(pipe.stdout.readline, b""):
            sys.stdout.write(line)
            if not line:
                if pipeIn.poll() is not None and pipe.poll() is not None:
                    break

        pipe.stdout.close()


# Ripgrep specific searching
class Rg(Search):
    def __init__(self, match):
        super(Rg, self).__init__()
        self.match = match

    def createCommand(self):
        parts = ["rg", "-i", "--glob", "**/*.md", "--no-heading", "-N"]
        if self.maxPerFile > 0:
            parts.extend(["-m", str(self.maxPerFile)])
        parts.append(self.matchPrefix + self.match)
        return parts


def search(args):
    match = " ".join(args.thing)

    if args.name == "default":
        search = Rg(match)
    elif args.name == "sort-modified":
        search = Rg(match)
        search.withModifiedKey = True
        search.sort = True
    elif args.name == "bookmarks":
        search = Rg(match)
        search.matchPrefix = "^\\[[0-9]+\\]:.*"
    elif args.name == "headings":
        search = Rg(match)
        search.matchPrefix = "^#+.*"
        search.postFilter = "s/\\#* //"
        search.withModifiedKey = True
        search.sort = True
    else:
        raise Exception(f"Search {args.name} not recognised")

    if args.nofilter:
        search.filter = None
    # search.maxPerFile = 1
    search.run(args)


run()
