#!/usr/bin/env python3

#
# Synchronise a local git repository with remote
#

import datetime
import os
import re
from subprocess import call, getoutput, STDOUT

fetch_window = 600


def is_git_repo(path):
    return os.path.isdir(path) and (
        call(
            ["git", "rev-parse"], cwd=path, stderr=STDOUT, stdout=open(os.devnull, "w")
        )
        == 0
    )


def get_branch_name():
    heads = getoutput("git describe --all")
    match = re.search("heads/(.*)", heads)
    if match:
        return match.group(1)
    raise Exception(
        f"heads of git repository is {heads} and does not match 'heads/*"
    )


def synk(path):
    if not is_git_repo(path):
        raise Exception(
            f"Directory {path} is not a git repository and can not be synked"
        )
    os.chdir(path)
    repository_name = os.path.basename(path)
    branch = get_branch_name()
    changes = int(getoutput("git status --porcelain | wc -l"))
    auto_commit = getoutput("git config core.autocommit") == "true"
    original_url = getoutput("git config --get remote.origin.url")

    if changes > 0:
        if auto_commit:
            os.system("git add -A ; git commit --quiet -m sync")
        else:
            print(f"∷ ◉ {repository_name} - set autocommit with git synk -a to commit local")
            return
    print("▻ ", end="")

    dated_file = f"{path}/.git/FETCH_HEAD"
    if not os.path.exists(dated_file):
        dated_file = f"{path}/.git/HEAD"
    last_modified = datetime.datetime.fromtimestamp(os.path.getmtime(dated_file))
    now = datetime.datetime.now()
    if last_modified + datetime.timedelta(seconds=fetch_window) < now:
        print(".", end="")
        print(".", end="")
    else:
        print("∷ ", end="")

    print("")


def run():
    cwd = os.getcwd()
    print(cwd)
    if is_git_repo(cwd):
        synk(cwd)
    else:
        for child in os.listdir(cwd):
            directory = os.path.join(cwd, child)
            if is_git_repo(directory):
                synk(directory)


run()
