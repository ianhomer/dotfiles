#!/usr/bin/env bash

#
# Safe synchronisation of git repository. Auto-commits can be enabled by setting
# the git config core.autocommit, i.e. run the following once in the repository
# directory
#
#    git synk -a
#
# Autocommitting should only be enabled when the commit messages are of limited
# value, for example personal / note style repositories.

set -e

help() {
  cat <<EOF

    git synk -a  # autocommit
    git synk -u  # unset autocommmit

EOF
}

OPTIND=1
while getopts "ahu" o; do case "$o" in
  a) git config core.autocommit true ;;
  u) git config --unset core.autocommit ;;
  h) help && exit 1 ;;
esac done

#
# Execute git quietly ... keybase output messages in stderr
# this function safely removes these known errors, but
# keeps unknown errors
#
function gitQuiet() {
  if [[ "$protocol" == "keybase" ]] ; then
    # Strip out noise from Keybase
    output=$(git $1 --quiet 2>&1)
    printf "$output"                   \
      | grep -v 'Initializing Keybase' \
      | grep -v 'Syncing with Keybase' \
      || :
  else
    git $1 --quiet
  fi
}

#
# Sync the current directory if possible
#
function gitSynk() {
  # Make sure in git repository
  git rev-parse

  printf "▻ "
  fullBranchName=$(git symbolic-ref -q HEAD)
  branchName=${fullBranchName##refs/heads/}
  originUrl=$(git config --get remote.origin.url)
  remoteName=$(git config --get branch.$branchName.remote)
  protocol=${originUrl%%\:*}

  current=`pwd | sed 's|.*/||g'`

  if git rebase --show-current-patch 2>&1>/dev/null ; then
    echo "$current - rebase in progress"
    return 1
  fi

  changes=$(git status --porcelain | wc -l)

  if [[ $changes -gt 0 ]] ; then
    if [[ "true" == `git config core.autocommit` ]] ; then
      # Handle dirty state only if autocommit flag set
      git add -A ; git commit --quiet -m "sync"
    else
      # Otherwise if there are local changes and the autocommit is not set then
      # we bomb
      echo "$current - local changes and autocommit not set"
      return 128
    fi
  fi

  gitQuiet fetch

  leftRight=$(git rev-list --count --left-right $remoteName/$branchName...HEAD)
  left=$(echo $leftRight | awk '{print $1}')
  right=$(echo $leftRight | awk '{print $2}')

  # Determine action about to take place
  if [[ $left -gt 0 ]] ; then
    if [[ $right -gt 0 ]] ; then
      action="↓ $left ↑ $right"
    else
      action="↓ $left"
    fi
  elif [[ $right -gt 0 ]] ; then
    action="↑ $right"
  else
    action="≡"
  fi

  reducer='s|\([a-z]\)[\.a-z]*\([\/@\:]\)|\1\2|g'
  reducedBranchName=`echo $branchName | sed -e $reducer`
  reducedOriginUrl=`echo $originUrl | sed -e $reducer`

  printf "$action $reducedBranchName ${reducedOriginUrl%%.git}"

  if [[ $left -gt 0 ]] ; then
    printf " ↓"
    gitQuiet rebase
  fi

  if [[ $right -gt 0 ]] ; then
    printf " ↑"
    gitQuiet "push"
  fi

  # Print AOK signal
  printf " ☆"
}

if git rev-parse 2>/dev/null  ; then
  # We're in a git directory, just go ahead and synk
  gitSynk || exit 128
else
  # We're not in a git directory, loop over child directories and if a child is
  # git directory then synk
  current=`pwd`
  first=1
  error=0
  for child in */ ; do
   cd ${current}
   if [ -d "${child}.git" ] ; then
     # Each subsequence synk on a new line
     [[ first -eq 0 ]] && printf "\n"
     cd $child
     gitSynk || error=1
     first=0
   fi
  done
  [[ $error -eq 0 ]] || exit $error
fi

