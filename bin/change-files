#!/usr/bin/env bash

#
# Change files in a given directory.
#
# e.g.
#
# Default with sed syntax
#
#    change-files . .md s#x#y#g
#
# JSON updates with jq syntax
#
#    change-files . .json '.author = "anon"'
#
# Only works in a git directory. This gives a level of protection against
# undesired changes.
#
# This is also a pattern library for auto changing files which can be lift and
# shifted as needed.
#

OPTIND=1
export INDENT=2
while getopts "di:qv" o; do case "$o" in
  i) export INDENT=$OPTARG ;;
  q) QUICK=y ;;
  d) DRY=y ;;
  v) VERBOSE=y ;;
esac done
shift $((OPTIND-1))
[ "${1:-}" = "--" ] && shift

printf "\e[37mchanging files\e[0m\n"
[ -z "$QUICK" ] || echo "Quick run"
[ -z "$DRY" ] || echo "Dry run"

directory=$1
fileSuffixes=$2
change=$3

[ -z "$directory" ] && echo "No directory" && exit
git -C "${directory}" rev-parse || exit
[ -z "$fileSuffixes" ] && echo "No files" && exit
[ -z "$change" ] && DRY=y


EXCLUDE_DIRECTORIES="node_modules dist"
for dir in $EXCLUDE_DIRECTORIES ; do
  [[ -z "$FIND_PRUNE" ]]                  \
    && FIND_PRUNE="-type d ( -name $dir" \
    || FIND_PRUNE+=" -o -name $dir"
  [[ -z "$EXCLUDE" ]]                  \
    && EXCLUDE="$dir" \
    || EXCLUDE+="|$dir"
done

# Find prune is a more efficient way for directories since it stops the find
# scan
FIND_PRUNE+=" ) -prune -false"

# File name exclusion for deep scan
EXCLUDE+="|package-lock.json"

deepChangeText() {
  echo "changing text : $1 : $2 : $3"
  # Allow suffixes to be seperated by a comma
  IFS=", "
  for suffix in $2 ; do
    [[ -z "$FIND_NAME" ]]                  \
      && FIND_NAME="-type f ( -name *$suffix" \
      || FIND_NAME+=" -o -name *$suffix"
  done
  FIND_NAME+=" )"

  # Disable glob expansion so that * goes through to find without being expanded
  # into file list by the shell
  set -o noglob
  # w => write changes to stdout
  find "$1" ${FIND_PRUNE[@]} -o ${FIND_NAME[@]} -print | egrep -v $EXCLUDE | \
    xargs -t -n 1 -P 10 sed -i '' "$3 w /dev/stdout"
  set +o noglob
}

deepChangeDry() {
  echo "dry run for : $1 : $2 : $3"
  #find "$1" -type d \( -name node_modules -o -name dist \) -prune -false -o -name "*$2" -print 
  find "$1" ${FIND_PRUNE[@]} -o -name "*$2" -print
}

changeJson() {
  change=$1
  file=$2
  # Inline json change with jq
  ORIGINAL=$(cat $file)
  TJQ=$(jq --indent "$INDENT" --sort-keys "$change" < $file)
  if [[ "${ORIGINAL}" == "${TJQ}" ]] ; then
    echo "no change json : $file : $change"
    return
  fi
  echo "changing json : $file : $change"
  [[ $? == 0 ]] && echo "${TJQ}" >| $file
}
# Export function so that it is available to bash from deepChangeJson xargs
export -f changeJson

deepChangeJson() {
  [[ -z "$VERBOSE" ]] || echo "changing json : $1 : $2 : $3"
  # Export change so that it can be passed into xargs bash
  # -P 10 => parallel 10
  # -n 1 => only take one argument (i.e. the file name from the stream)
  find "$1" -name "*$2" -print | egrep -v $EXCLUDE | \
    CHANGE="$3" xargs -n 1 -P 10 -I {}               \
    bash -c 'changeJson "$CHANGE" "$@"' _ {}
}

mode="dry"
if [[ "${change:0:1}" = "#" || "${change:0:2}" = "s#" ]] ; then
  mode="sed"
elif [[ "${fileSuffixes: -5}" = ".json" ]] ; then
  mode="jq"
fi

case "$mode" in
  dry) deepChangeDry "$directory" "$fileSuffixes" "$change" ;;
  sed) deepChangeText "$directory" "$fileSuffixes" "$change" ;;
  jq)  deepChangeJson "$directory" "$fileSuffixes" "$change" ;;
esac
